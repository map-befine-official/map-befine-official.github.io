{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"이 글은 우아한테크코스 괜찮을지도팀의 가 작성했습니다I 테스트 간 격리.. 왜 필요할까? 우리는 프로덕션 코드의 신뢰성을 보장하기 위해서 테스트 코드를 작성한다. 그렇기 때문에, 테스트 코드는 100번을 실행시키던 100만번을 실행시키던, 동일한 결과를 내뱉어야한다. 테스트 코드를 아무리 잘 작성하더라도, 매번 테스트의 결과가 다르다면 의미가 없다. 예를…","fields":{"slug":"/how-to-isolating-test/"},"frontmatter":{"date":"July 31, 2023","title":"인수테스트에서 테스트 격리하기!","tags":["테스트","데이터베이스"]},"rawMarkdownBody":"\n> 이 글은 우아한테크코스 괜찮을지도팀의 `매튜`가 작성했습니다I\n\n## 테스트 간 격리.. 왜 필요할까?\n\n우리는 프로덕션 코드의 신뢰성을 보장하기 위해서 테스트 코드를 작성한다.\n\n그렇기 때문에, 테스트 코드는 100번을 실행시키던 100만번을 실행시키던, 동일한 결과를 내뱉어야한다.\n\n테스트 코드를 아무리 잘 작성하더라도, 매번 테스트의 결과가 다르다면 의미가 없다.\n\n예를 들어 아래와 같은 테스트가 있다고 해보자.\n\n```java\n@DataJpaTest\npublic class ExampleTest {  \n\n    @Autowired  \n    private PinRepository pinRepository;  \n      \n    @Test  \n    void 모든_핀을_조회한다() {  \n        // given  \n        Pin pin = new Pin(...);  \n        pinRepository.save(pin);  \n          \n        // when  \n        List<Pin> pins = pinRepository.findAll();  \n  \n        // then  \n        assertAll(  \n                () -> assertThat(pins).hasSize(1),  \n                () -> assertThat(pins.get(0)).isEqualTo(pin)  \n        );  \n    }  \n\n}\n```\n\n정상적인 경우라면, 위 테스트는 통과해야한다.\n\n하지만, 테스트 간 격리를 진행하지 않은 상태에서 이 테스트 이전에 다른 테스트에서 pin 을 저장하는 동작을 수행했고, 데이터를 지워주지 않았다면?\n\n해당 테스트는 실패하게 될 것이다.\n\n위 테스트는 이전에 수행된 테스트들의 동작에도 영향을 받는, 독립적이지 못한 테스트가 된 것이다.\n\n이것이 바로 테스트 간 격리가 필요한 이유이다.\n\n그렇다면 위와 같은 상황을 @Transactional 어노테이션만으로 완벽하게 예방할 수 있을까?\n\n결론부터 말하자면 그럴 수 없다.\n\n@SpringBootTest 를 사용하는 인수테스트 같은 경우는 Port 를 지정하여 서버를 띄우게 되는데, 이 때 HTTP 클라이언트와 서버는 각기 다른 스레드에서 실행되게 된다.\n\n그렇기 때문에 테스트 코드에 @Transactional 있더라도 호출되는 쪽은 다른 스레드에서 새로운 트랜잭션을 커밋하기 때문에, 롤백 전략은 무색해지게 되고, 테스트 간 격리도 제대로 이행될 수가 없는 것이다.\n\n## 그렇다면 격리를 위해 사용할 수 있는 방법들은 무엇이 있을까?\n\n이번 포스트를 통해서 다뤄볼 방법은 3가지이다.\n\n바로 `Dirtiest Context`,  `@Sql 어노테이션`, `Entity Manager` 이다.\n\n하나씩 짚어보면서 넘어가보자.\n\n### DirtiesContext\n\n```java\n@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)  \n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class ExampleTest {\n\t...\n}\n```\n\n`DiriesContext` 는 현재 테스트를 실행하고자 하는 컨텍스트에 빈이 로드되어 있으면 Dirties 를 확인하고 Bean 들을 Reload 하게 된다.\n\n즉, 테이블도 다시 만들기 때문에 테스트 간의 격리가 가능하다.\n\n하지만, 매번 테스트하기 이전에 컨텍스트를 Reload 하게 된다면, 테스트 시간은 한없이 길어지게 될 것이기 때문이다.\n\n테스트의 장점은 프로덕션 코드의 신뢰성을 보장함에도 존재하지만, 개발자가 개발을 진행중에 코드를 올바르게 작성중인지 바로 바로 응답받기 위한 수단이기도 하다.\n\n따라서, 응답 속도는 개발 진행 속도와 크게 연관되어 있는 것이다.\n\n하지만, 인수테스트에 DirtiesContext 를 난사하게 되면, 매 테스트 실행마다 속이 터지는 경험을 하게 될 것이다.\n\n### @Sql 어노테이션\n\n해당 방법은 꽤나 획기적인 방법이다.\n\n간단한 sql 구문만으로 테스트 간의 격리를 이뤄낼 수 있다. \n\n어떤 이는 외래키 제약 조건으로 인해 한번에 데이터를 삭제하는 것이 불가능하다고 생각할 수도 있지만, 아래 코드와 같이 외래키 제약 조건을 해제해주고 데이터를 삭제하는 것이 가능하다. \n\n```sql\nSET FOREIGN_KEY_CHECKS = 0;  \nTRUNCATE TABLE 테이블이름;  \n...\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n```java\n@DataJpaTest\n@Sql(\"/truncate.sql\")\npublic class ExampleTest {  \n\t...\n}\n```\n\n하지만, 해당 방법에도 단점은 존재한다.\n\n바로, 테이블이 추가될 때마다, 해당 sql 구문을 수정해주어야 한다는 것이다.\n\n큰 단점은 아니지만, 항상 신경써주어야 한다는 점에서 조금은 아쉽다는 생각이 든다. \n\n### Entity Manager\n\n위에서도 언급하였듯 `@Sql` 어노테이션은 정말 강력하지만, 테이블이 추가될 때마다 sql 구문을 다시 수정해주어야 한다는 단점이 존재했다.\n\n이 때, `@Sql` 어노테이션의 장점을 모두 가져가면서, 위에서 언급한 단점도 보완할 수 있는 방법이 있다.\n\n바로 `Entity Manager` 를 활용하는 방법이다.\n\n도대체 어떻게? `Entity Manager` 를 통해서 Data 를 지운다는 것일까?\n\n우리는 개발자이니 코드를 통해 살펴보자. \n\n```java\n@Componenet  \npublic class DatabaseCleanup implements InitializingBean {  \n\n\tprivate static final String UNDERSCORE = \"_\";\n  \n    @PersistenceContext  \n    private EntityManager entityManager;  \n  \n    private List<String> tableNames;  \n  \n    @Override  \n    public void afterPropertiesSet() {  \n        tableNames = entityManager.getMetamodel().getEntities().stream()  \n                .filter(entityType -> entityType.getJavaType().getAnnotation(Entity.class) != null)  \n                .map(entityType -> convertTableNameFromCamelCaseToSnakeCase(entityType.getName()))  \n                .toList();  \n    }  \n\n    private String convertTableNameFromCamelCaseToSnakeCase(String tableName) {  \n        StringBuilder tableNameSnake = new StringBuilder();  \n  \n        for (char letter : tableName.toCharArray()) {  \n            addUnderScoreForCapitalLetter(tableNameSnake, letter);  \n            tableNameSnake.append(letter);  \n        }  \n  \n        return tableNameSnake.substring(1).toLowerCase();  \n    }  \n  \n    private void addUnderScoreForCapitalLetter(StringBuilder tableNameSnake, char letter) {  \n        if (Character.isUpperCase(letter)) {  \n            tableNameSnake.append(UNDERSCORE);  \n        }  \n    }  \n  \n}\n```\n\nEntity Manager 를 통해 데이터를 관리하기 위해 DatabaseCleanup 이라는 객체를 생성해줬다.\n\n`InitializingBean` 을 implements 해 `afterPropertiesSet` 메서드를 구현하게되면, 프로퍼티가 모두 초기화되었을 때, BeanFactory에 의해 자동으로 해당 메서드가 호출되게 된다.\n\n그러니, 해당 메서드의 내부 구현으로 Entity 들의 ClassName 을 이용하여 모든 테이블명을 생성해내어 저장하면 된다. (Entity Class 명을 Camel Case -> Snake Case 로 변환해준다. `convertTableNameFromCamelCaseToSnakeCase` 가 해당 동작을 수행해주고 있다.)\n\n위와 같이 모든 테이블명을 생성해내어 저장했다면, 해당 테이블 명들을 이용하여 Data 를 모두 지워주는 execute 를 구현해주자.\n\n```java\n@Service  \npublic class DatabaseCleanup implements InitializingBean {  \n\n\tprivate static final String SET_REFERENTIAL_INTEGRITY_SQL_MESSAGE = \"SET REFERENTIAL_INTEGRITY %s\";  \n\tprivate static final String TRUNCATE_SQL_MESSAGE = \"TRUNCATE TABLE %s\";  \n\tprivate static final String ID_RESET_SQL_MESSAGE = \"ALTER TABLE %s ALTER COLUMN ID RESTART WITH 1\";  \n  \n    @PersistenceContext  \n    private EntityManager entityManager;  \n  \n    private List<String> tableNames;  \n\n\t...\n\n\t@Transactional  \n\tpublic void execute() {  \n\t    entityManager.flush();  \n\t    entityManager.createNativeQuery(String.format(SET_REFERENTIAL_INTEGRITY_SQL_MESSAGE, false)).executeUpdate();  \n\t  \n\t    for (String tableName : tableNames) {  \n\t        entityManager.createNativeQuery(String.format(TRUNCATE_SQL_MESSAGE, tableName)).executeUpdate();  \n\t        entityManager.createNativeQuery(String.format(ID_RESET_SQL_MESSAGE, tableName)).executeUpdate() ;  \n\t    }  \n\t  \n\t    entityManager.createNativeQuery(String.format(SET_REFERENTIAL_INTEGRITY_SQL_MESSAGE, true)).executeUpdate();  \n\t}\n\t  \n}\n```\n\n위의 코드를 순서대로 간단하게 설명해보자면\n\n1. 외래키 제약조건을 비활성화 해준다. \n2. `afterPropertiesSet` 을 통해 생성해놓은 모든 테이블 명들을 이용하여 Data 들을 모두 Truncate 해주고, ID 값을 다시 세팅해준다.\n3. 외래키 제약조건을 활성화해준다. \n\n이런 Flow 로 흘러가는 execute 메서드를 구현해주었다면\n\n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)  \npublic class ExampleTest {  \n  \n    @LocalServerPort  \n    private int port;  \n  \n    @Autowired  \n    private DatabaseCleanup databaseCleanup;  \n  \n    @BeforeEach  \n    public void setUp() {  \n        RestAssured.port = port;  \n    }  \n  \n    @AfterEach  \n    public void tearDown() {  \n        databaseCleanup.execute();  \n    }  \n  \n}\n```\n\n위 코드와 같이 @AfterEach 를 통해 매 인수테스트 동작 이후 실행시켜주면, 모든 테스트들을 격리할 수 있게 되는 것이다.\n\n\n## 결론\n\n지금으로서는 데이터 삭제가 쉽고, 테이블이 추가되었을 때 sql 구문을 수정하지 않아도 되는 `Entity Manager` 를 통해 테스트를 격리하는 것이 최선의 방법으로 보인다.\n\n하지만, 추후에 이보다 더 좋은 방법을 발견하면, 면밀히 검토해보고 바꿀 의사가 충분하다고 생각한다.\n\n## 참고\n\nhttps://tecoble.techcourse.co.kr/post/2020-09-15-test-isolation/\n"},{"excerpt":"이 글은 우테코 괜찮을지도팀의 가 작성했습니다. 첫 글은 포스트 작성법에 대해서 다루어보도록 하겠습니다. Repository Local 로 Clone 해오기 본인이 원하는 Directory 로 이동해  위와 같은 명령어를 이용하여 우리 팀의 Repository 를 Local 로 가져옵니다. 글 작성하기 Repository 를 Local 로 가져오셨다면, …","fields":{"slug":"/how-to-write-a-post/"},"frontmatter":{"date":"July 24, 2023","title":"포스트 작성 방법","tags":["블로그"]},"rawMarkdownBody":"\n> 이 글은 우테코 괜찮을지도팀의 `매튜`가 작성했습니다.\n\n첫 글은 포스트 작성법에 대해서 다루어보도록 하겠습니다.\n\n### Repository Local 로 Clone 해오기 \n\n본인이 원하는 Directory 로 이동해 \n\n```shell\ngit clone https://github.com/map-befine-official/map-befine-official.github.io \n``` \n\n위와 같은 명령어를 이용하여 우리 팀의 Repository 를 Local 로 가져옵니다.\n\n## 글 작성하기\n\nRepository 를 Local 로 가져오셨다면, 이제 글을 작성해봅시다!\n\n```shell\ncd map-befine-official.github.io\n```\n\n위 명령어를 통해서 map-befine-official.github.io 에 Directory 에 들어가주시면 Contents Directory 가 보이실 겁니다.\n\n여기서 \n\n```shell\ncd contents/posts\n```\n\n위 명령어를 통해 contents/posts 디렉토리 내부까지 가고\n\n본인이 작성하고자 하는 주제에 걸맞는 이름으로 Directory 를 생성한 후, 만드신 Directory까지 들어가주세요\n\n저 같은 경우는 Directory 명을 how-to-write-a-post 로 지었기 때문에\n\n```shell\ncd how-to-write-a-post\n```\n\n위와 같은 명령어를 통해 이동 해주었습니다.\n\n![](.index_image/command.png)\n\n여기서부터 이제 `index.md` 파일을 만들어 작성하실 글을 Markdown 형식으로 작성 해주시면되고, `.index_image` 라는 이름으로 Directory 만들어 해당 Directory 에 이미지 파일을 넣어주시면 됩니다.\n\n잘 따라오셨다면 최종적으로 이런 구조가 나올겁니다!\n\n![](.index_image/directory_structure.png)\n\n## 글 올리기!\n\n글을 모두 작성하셨다면 이제 올리기만 하면 될 겁니다.\n\n아주 쉽습니다.\n\n그냥 main 브랜치에 push 를 하시면돼요!\n\n`.github/workflows/deploy.yml` 로 인해서 push 만 하셔도 배포 될겁니다.\n\n야물딱지죠?\n\n우리 글도 한번 야무지게 써봅시다!\n\n## 글의 제목 작성하기\n\n글의 서두에 \n\n```text\n---\ntitle: \"제목\"\ndescription: \"설명\"\ndate: \"작성 날짜\"\nupdate: \"수정 날짜\"\ntags:\n  - 태그들\n  - ...\n---\n```\n\n이런 식으로 작성해주셔야지 \n\n![](.index_image/title.png)\n\n위에서 보시는 바와 같이 하실 수 있습니다.\n\n## 이미지 삽입\n\n이미지를 삽입하시고 싶으시다면, \n\n저의 가이드를 모두 잘 따르셨다고 가정했을 때, .index_image 내부에 image 파일을 넣고\n\n```text\n![](.index_image/{이미지 파일 명})\n```\n\n이런 식으로 작성해주시면 이미지도 정상적으로 삽입하실  수 있습니다!\n\n## 주의!\n\n다른 사람들의 정성스런 글을 날리지 않기 위해, 항상 Push 이전에 Pull 해주는 거 잊지 않으셨죠? ㅋㅋㅋ\n\n물론 Warning Message 가 뜨긴 할테지만, 잊지 말아주세용~~~\n\n## 레퍼런스 \n\nhttps://pium-official.github.io/blog-starter/\n\n\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}