{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"이 글은 우아한테크코스 괜찮을지도팀의 가 작성했습니다I 테스트 간 격리.. 왜 필요할까? 우리는 프로덕션 코드의 신뢰성을 보장하기 위해서 테스트 코드를 작성한다. 그렇기 때문에, 테스트 코드는 100번을 실행시키던 100만번을 실행시키던, 동일한 결과를 내뱉어야한다. 테스트 코드를 아무리 잘 작성하더라도, 매번 테스트의 결과가 다르다면 의미가 없다. 예를…","fields":{"slug":"/how-to-isolating-test/"},"frontmatter":{"date":"July 31, 2023","title":"인수테스트에서 테스트 격리하기!","tags":["테스트","데이터베이스"]},"rawMarkdownBody":"\n> 이 글은 우아한테크코스 괜찮을지도팀의 `매튜`가 작성했습니다I\n\n## 테스트 간 격리.. 왜 필요할까?\n\n우리는 프로덕션 코드의 신뢰성을 보장하기 위해서 테스트 코드를 작성한다.\n\n그렇기 때문에, 테스트 코드는 100번을 실행시키던 100만번을 실행시키던, 동일한 결과를 내뱉어야한다.\n\n테스트 코드를 아무리 잘 작성하더라도, 매번 테스트의 결과가 다르다면 의미가 없다.\n\n예를 들어 아래와 같은 테스트가 있다고 해보자.\n\n```java\n@DataJpaTest\npublic class ExampleTest {  \n\n    @Autowired  \n    private PinRepository pinRepository;  \n      \n    @Test  \n    void 모든_핀을_조회한다() {  \n        // given  \n        Pin pin = new Pin(...);  \n        pinRepository.save(pin);  \n          \n        // when  \n        List<Pin> pins = pinRepository.findAll();  \n  \n        // then  \n        assertAll(  \n                () -> assertThat(pins).hasSize(1),  \n                () -> assertThat(pins.get(0)).isEqualTo(pin)  \n        );  \n    }  \n\n}\n```\n\n정상적인 경우라면, 위 테스트는 통과해야한다.\n\n하지만, 테스트 간 격리를 진행하지 않은 상태에서 이 테스트 이전에 다른 테스트에서 pin 을 저장하는 동작을 수행했고, 데이터를 지워주지 않았다면?\n\n해당 테스트는 실패하게 될 것이다.\n\n위 테스트는 이전에 수행된 테스트들의 동작에도 영향을 받는, 독립적이지 못한 테스트가 된 것이다.\n\n이것이 바로 테스트 간 격리가 필요한 이유이다.\n\n그렇다면 위와 같은 상황을 @Transactional 어노테이션만으로 완벽하게 예방할 수 있을까?\n\n결론부터 말하자면 그럴 수 없다.\n\n@SpringBootTest 를 사용하는 인수테스트 같은 경우는 Port 를 지정하여 서버를 띄우게 되는데, 이 때 HTTP 클라이언트와 서버는 각기 다른 스레드에서 실행되게 된다.\n\n그렇기 때문에 테스트 코드에 @Transactional 있더라도 호출되는 쪽은 다른 스레드에서 새로운 트랜잭션을 커밋하기 때문에, 롤백 전략은 무색해지게 되고, 테스트 간 격리도 제대로 이행될 수가 없는 것이다.\n\n## 그렇다면 격리를 위해 사용할 수 있는 방법들은 무엇이 있을까?\n\n이번 포스트를 통해서 다뤄볼 방법은 3가지이다.\n\n바로 `Dirtiest Context`,  `@Sql 어노테이션`, `Entity Manager` 이다.\n\n하나씩 짚어보면서 넘어가보자.\n\n### DirtiesContext\n\n```java\n@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)  \n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class ExampleTest {\n\t...\n}\n```\n\n`DiriesContext` 는 현재 테스트를 실행하고자 하는 컨텍스트에 빈이 로드되어 있으면 Dirties 를 확인하고 Bean 들을 Reload 하게 된다.\n\n즉, 테이블도 다시 만들기 때문에 테스트 간의 격리가 가능하다.\n\n하지만, 매번 테스트하기 이전에 컨텍스트를 Reload 하게 된다면, 테스트 시간은 한없이 길어지게 될 것이기 때문이다.\n\n테스트의 장점은 프로덕션 코드의 신뢰성을 보장함에도 존재하지만, 개발자가 개발을 진행중에 코드를 올바르게 작성중인지 바로 바로 응답받기 위한 수단이기도 하다.\n\n따라서, 응답 속도는 개발 진행 속도와 크게 연관되어 있는 것이다.\n\n하지만, 인수테스트에 DirtiesContext 를 난사하게 되면, 매 테스트 실행마다 속이 터지는 경험을 하게 될 것이다.\n\n### @Sql 어노테이션\n\n해당 방법은 꽤나 획기적인 방법이다.\n\n간단한 sql 구문만으로 테스트 간의 격리를 이뤄낼 수 있다. \n\n어떤 이는 외래키 제약 조건으로 인해 한번에 데이터를 삭제하는 것이 불가능하다고 생각할 수도 있지만, 아래 코드와 같이 외래키 제약 조건을 해제해주고 데이터를 삭제하는 것이 가능하다. \n\n```sql\nSET FOREIGN_KEY_CHECKS = 0;  \nTRUNCATE TABLE 테이블이름;  \n...\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n```java\n@DataJpaTest\n@Sql(\"/truncate.sql\")\npublic class ExampleTest {  \n\t...\n}\n```\n\n하지만, 해당 방법에도 단점은 존재한다.\n\n바로, 테이블이 추가될 때마다, 해당 sql 구문을 수정해주어야 한다는 것이다.\n\n큰 단점은 아니지만, 항상 신경써주어야 한다는 점에서 조금은 아쉽다는 생각이 든다. \n\n### Entity Manager\n\n위에서도 언급하였듯 `@Sql` 어노테이션은 정말 강력하지만, 테이블이 추가될 때마다 sql 구문을 다시 수정해주어야 한다는 단점이 존재했다.\n\n이 때, `@Sql` 어노테이션의 장점을 모두 가져가면서, 위에서 언급한 단점도 보완할 수 있는 방법이 있다.\n\n바로 `Entity Manager` 를 활용하는 방법이다.\n\n도대체 어떻게? `Entity Manager` 를 통해서 Data 를 지운다는 것일까?\n\n우리는 개발자이니 코드를 통해 살펴보자. \n\n```java\n@Componenet  \npublic class DatabaseCleanup implements InitializingBean {  \n\n\tprivate static final String UNDERSCORE = \"_\";\n  \n    @PersistenceContext  \n    private EntityManager entityManager;  \n  \n    private List<String> tableNames;  \n  \n    @Override  \n    public void afterPropertiesSet() {  \n        tableNames = entityManager.getMetamodel().getEntities().stream()  \n                .filter(entityType -> entityType.getJavaType().getAnnotation(Entity.class) != null)  \n                .map(entityType -> convertTableNameFromCamelCaseToSnakeCase(entityType.getName()))  \n                .toList();  \n    }  \n\n    private String convertTableNameFromCamelCaseToSnakeCase(String tableName) {  \n        StringBuilder tableNameSnake = new StringBuilder();  \n  \n        for (char letter : tableName.toCharArray()) {  \n            addUnderScoreForCapitalLetter(tableNameSnake, letter);  \n            tableNameSnake.append(letter);  \n        }  \n  \n        return tableNameSnake.substring(1).toLowerCase();  \n    }  \n  \n    private void addUnderScoreForCapitalLetter(StringBuilder tableNameSnake, char letter) {  \n        if (Character.isUpperCase(letter)) {  \n            tableNameSnake.append(UNDERSCORE);  \n        }  \n    }  \n  \n}\n```\n\nEntity Manager 를 통해 데이터를 관리하기 위해 DatabaseCleanup 이라는 객체를 생성해줬다.\n\n`InitializingBean` 을 implements 해 `afterPropertiesSet` 메서드를 구현하게되면, 프로퍼티가 모두 초기화되었을 때, BeanFactory에 의해 자동으로 해당 메서드가 호출되게 된다.\n\n그러니, 해당 메서드의 내부 구현으로 Entity 들의 ClassName 을 이용하여 모든 테이블명을 생성해내어 저장하면 된다. (Entity Class 명을 Camel Case -> Snake Case 로 변환해준다. `convertTableNameFromCamelCaseToSnakeCase` 가 해당 동작을 수행해주고 있다.)\n\n위와 같이 모든 테이블명을 생성해내어 저장했다면, 해당 테이블 명들을 이용하여 Data 를 모두 지워주는 execute 를 구현해주자.\n\n```java\n@Service  \npublic class DatabaseCleanup implements InitializingBean {  \n\n\tprivate static final String SET_REFERENTIAL_INTEGRITY_SQL_MESSAGE = \"SET REFERENTIAL_INTEGRITY %s\";  \n\tprivate static final String TRUNCATE_SQL_MESSAGE = \"TRUNCATE TABLE %s\";  \n\tprivate static final String ID_RESET_SQL_MESSAGE = \"ALTER TABLE %s ALTER COLUMN ID RESTART WITH 1\";  \n  \n    @PersistenceContext  \n    private EntityManager entityManager;  \n  \n    private List<String> tableNames;  \n\n\t...\n\n\t@Transactional  \n\tpublic void execute() {  \n\t    entityManager.flush();  \n\t    entityManager.createNativeQuery(String.format(SET_REFERENTIAL_INTEGRITY_SQL_MESSAGE, false)).executeUpdate();  \n\t  \n\t    for (String tableName : tableNames) {  \n\t        entityManager.createNativeQuery(String.format(TRUNCATE_SQL_MESSAGE, tableName)).executeUpdate();  \n\t        entityManager.createNativeQuery(String.format(ID_RESET_SQL_MESSAGE, tableName)).executeUpdate() ;  \n\t    }  \n\t  \n\t    entityManager.createNativeQuery(String.format(SET_REFERENTIAL_INTEGRITY_SQL_MESSAGE, true)).executeUpdate();  \n\t}\n\t  \n}\n```\n\n위의 코드를 순서대로 간단하게 설명해보자면\n\n1. 외래키 제약조건을 비활성화 해준다. \n2. `afterPropertiesSet` 을 통해 생성해놓은 모든 테이블 명들을 이용하여 Data 들을 모두 Truncate 해주고, ID 값을 다시 세팅해준다.\n3. 외래키 제약조건을 활성화해준다. \n\n이런 Flow 로 흘러가는 execute 메서드를 구현해주었다면\n\n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)  \npublic class ExampleTest {  \n  \n    @LocalServerPort  \n    private int port;  \n  \n    @Autowired  \n    private DatabaseCleanup databaseCleanup;  \n  \n    @BeforeEach  \n    public void setUp() {  \n        RestAssured.port = port;  \n    }  \n  \n    @AfterEach  \n    public void tearDown() {  \n        databaseCleanup.execute();  \n    }  \n  \n}\n```\n\n위 코드와 같이 @AfterEach 를 통해 매 인수테스트 동작 이후 실행시켜주면, 모든 테스트들을 격리할 수 있게 되는 것이다.\n\n\n## 결론\n\n지금으로서는 데이터 삭제가 쉽고, 테이블이 추가되었을 때 sql 구문을 수정하지 않아도 되는 `Entity Manager` 를 통해 테스트를 격리하는 것이 최선의 방법으로 보인다.\n\n하지만, 추후에 이보다 더 좋은 방법을 발견하면, 면밀히 검토해보고 바꿀 의사가 충분하다고 생각한다.\n\n## 참고\n\nhttps://tecoble.techcourse.co.kr/post/2020-09-15-test-isolation/\n"},{"excerpt":"이 글은 우테코 괜찮을지도의 가 작성하였습니다. 배경 괜찮을지도 서비스는 CI/CD 툴로 Github Actions를 적용하였습니다.\n 자세한 내용이 궁금하다면 ? 괜찮을지도 CI/CD 구축기 바로가기 프로젝트의 설정 파일(.yml)은 DB 주소 등 민감한 정보를 담고 있었기 때문에, 이를 저장소에 그대로 업로드할 수 없었습니다.\n위 문제점을 해결하기 위…","fields":{"slug":"/trouble-shooting-actions-runner/"},"frontmatter":{"date":"July 31, 2023","title":"EC2 환경 변수 적용 및 Actions Runner에 환경 변수 적용이 안되는 이슈","tags":["인프라","Actions Runner"]},"rawMarkdownBody":"\n> 이 글은 우테코 괜찮을지도의 `쥬니`가 작성하였습니다.\n\n### 배경\n\n괜찮을지도 서비스는 CI/CD 툴로 Github Actions를 적용하였습니다.\n<br> 자세한 내용이 궁금하다면 ? [괜찮을지도 CI/CD 구축기 바로가기](/contents/posts/github-actions-ci-cd/index.md)\n\n프로젝트의 설정 파일(.yml)은 DB 주소 등 민감한 정보를 담고 있었기 때문에, 이를 저장소에 그대로 업로드할 수 없었습니다.\n<br>위 문제점을 해결하기 위한 과정과 실제 우리가 직면한 문제를 설명해 드리고자 합니다.\n\n### 환경변수 적용\n괜찮을지도는 환경 변수를 활용하여 민감한 정보를 숨기기로 했습니다.\n이에 따라, 각 배포 환경(prod, dev)에 맞는 설정 파일을 아래와 같이 작성하였습니다.\n```yaml\n# `application-dev`의 일부 \nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: ${MYSQL_DATABASE_URL} \n    username: ${MYSQL_DATABASE_USER_NAME}\n    password: ${MYSQL_DATABASE_PASSWORD}\n```\n설정 파일에서 사용한 환경 변수는 각 EC2 인스턴스에서 관리하도록 하였습니다.\n<br>EC2 인스턴스에 환경변수를 적용하는 방법은 아래와 같습니다.\n\n`1. EC2 터미널에 접속한다.`\n\n`2. 'sudo vim ~/.bashrc' 명령어를 입력한다.`\n\n`3. .bashrc 파일의 맨 아래에 아래와 같이 필요한 환경변수를 입력한 뒤, 저장한다.`\n```shell\n# ...\n# 기존 .bashrc 코드 생략 \n#\n# Database\nexport profile='dev'\nexport MYSQL_DATABASE_URL='Database url'\nexport MYSQL_DATABASE_USER_NAME='User name'\nexport MYSQL_DATABASE_PASSWORD='Password'\n```\n\n`4. 'source ~/.bashrc' 명령어를 입력하여 환경변수를 업데이트해 준다.`\n\n`5. 'echo $profile' 명령어를 입력하여 환경변수가 적용되었는지 확인한다.`\n\n### 환경 변수가 Actions Runner 동작에 적용되지 않는 이슈\n\n우리는 위 과정을 통해, 환경 변수가 EC2에 올바르게 적용된 것을 확인했습니다.\n<br>실제로, 아래와 같은 명령어를 통해 어플리케이션을 실행할 경우 `profile`로 설정한 환경변수인 dev가 올바르게 적용되는 것을 확인할 수 있었습니다.\n```shell\n# $JAR_FILE_PATH는 'deploy.sh' 파일 내에 존재하는 jar 파일의 경로를 나타내는 변수입니다.\nnohup sudo -E java -jar $JAR_FILE_PATH/mapbefine.jar --spring.profiles.active=$profile >> $JAR_FILE_PATH/deploy.log 2> $JAR_FILE_PATH/deploy-err.log &\n```\n![](.index_image/active-profile-dev.png)\n\n하지만, Actions Runner를 통해 CD를 수행하는 경우 아래와 같이 환경 변수가 적용되지 않았습니다.\n![](.index_image/active-profile-default.png)\n\n### 원인 및 문제 해결\n우리는 위 문제를 해결하기 위해, 아래와 같이 우리의 상황을 정리하였습니다.\n1. 터미널에서 쉘 스크립트를 실행할 경우, 환경 변수가 적용된다.\n2. Actions Runner를 통해 쉘 스크립트를 실행할 경우, 환경변수가 적용되지 않는다.\n3. CI/CD를 구축한 뒤에 환경 변수를 적용했다.\n\n위 상황을 통해, 우리는 환경 변수를 적용하기 전, 이미 실행되고 있었던 Actions Runner에 환경변수가 적용되지 않았음을 직감할 수 있었습니다.\n<br>실제로, 환경 변수는 프로세스가 시작될 때 해당 프로세스에게 제공되는 환경 설정의 일부이기 때문에, 위와 같은 문제가 발생한 것이었습니다.\n\n기존에 실행되고 있었던 Actions Runner 프로세스를 종료한 후, 재시작을 하였고 환경 변수가 올바르게 적용되는 것을 확인할 수 있었습니다.\n"},{"excerpt":"이 글은 우테코 괜찮을지도팀의 가 작성했습니다. 보다 편리하고 안정적인 개발 및 배포를 위해, 괜찮을지도 서비스에 CI/CD를 적용하였습니다. 이를 위한 도구로 GitHub Actions(self hosted runner)를 선택한 이유와, 파이프라인, 적용 방법에 대해 설명드리겠습니다. GitHub Actions를 사용한 이유 먼저 저희의 상황을 설명드…","fields":{"slug":"/github-actions-ci-cd/"},"frontmatter":{"date":"July 29, 2023","title":"GitHub Actions로 CI/CD 구축하기","tags":["인프라"]},"rawMarkdownBody":"\n> 이 글은 우테코 괜찮을지도팀의 `도이`가 작성했습니다.\n\n보다 편리하고 안정적인 개발 및 배포를 위해, 괜찮을지도 서비스에 CI/CD를 적용하였습니다.  \n이를 위한 도구로 GitHub Actions(self hosted runner)를 선택한 이유와, 파이프라인, 적용 방법에 대해 설명드리겠습니다.\n\n## GitHub Actions를 사용한 이유\n\n먼저 저희의 상황을 설명드리자면, \n아래와 같은 제약 사항 안에서 개발 서버, 운영 서버의 분리가 필요했습니다.\n\n### 제약 사항\n- EC2 최대 3개\n- 최대 t4g.small\n- 최대 20GiB\n- 매모리 2GiB\n\n운영 서버에서 사용하는 DB는 서버 분리가 필요하다고 판단해, 세 대의 인스턴스를 각각 아래 그림과 같이 개발, 운영, 운영 DB 서버로 분담했습니다.  \n그리고 이 제약 사항 안에서 알뜰하게 서버를 사용하고 트러블 슈팅하는 것을 저희의 기술적 도전으로 삼고자 합니다.\n\n### 인프라 구조\n![](.index_image/infra.jpeg)\n \n팀원들 모두가 CI/CD에 능숙하지 않은 상황에서 상대적으로 대중적이고 관련 자료를 쉽게 접할 수 있는 기술을 생각했을 때,  \nJenkins와 GitHub Actions가 고려 대상이었습니다.\n\n아래와 같은 이유로, 둘 중 GitHub Actions를 사용해 최대한 간단하게 CI/CD를 구축하는 것이 적합하다고 판단했습니다.  \n\n1. 메모리 부담 최소화\n   - Jenkins를 사용하면, EC2에서 빌드 및 테스트를 수행해야 합니다.\n   - 반면, GitHub Actions는 GitHub Artifact에 업로드한 빌드 결과물을 EC2에서 다운로드하면 됩니다.\n   - 실제로 한 팀원이 EC2 t2g.micro에 젠킨스 CI/CD를 적용했다가, 메모리가 부족해 서버가 죽는 과거의 경험을 공유해주었습니다.\n   - 때문에 적어도 CI 만큼은 GitHub Actions로 분리해 테스트 실행을 외부 서비스에 위임하기로 했습니다.\n   - 하지만 그렇다면, 간결한 파이프라인을 위해 CI/CD를 모두 GitHub Actions로 통합하는 것이 좋다고 판단했습니다.\n   > 실제로 가동중인 상황에서 확인해본 결과, 전체 메모리의 최대 0.7%만을 사용함을 알 수 있었습니다.   \n   ![actions-runner-usage.png](.index_image/actions-runner-usage.png)\n2. 쉽고 빠른 적용 \n   - GitHub 레포지토리에서 바로 설정이 가능해 기존 개발 환경과 통합해 사용 가능합니다.\n   - YAML 파일 작성만으로도 쉽고 빠른 적용이 가능합니다.\n   - GitHub가 Runner를 관리해주기 때문에, 서버 관리 부담이 덜합니다.\n  \n  \n## CI/CD 파이프라인\n![](.index_image/cicd-pipeline.jpeg)\nCI/CD 파이프라인은 다음과 같습니다.  \n1. Pull Request의 생성 또는 업데이트, Pull Request에 대한 Merge가 발생합니다.\n2. 이벤트에 트리거된 `GitHub Actions workflow`가 실행됩니다.\n3. `workflow`에 작성한 내용에 의해, `GitHub hosting Runner`가 빌드 및 테스트를 수행합니다.\n   - 이 때, 테스트 결과를 PR 코멘트로 등록해줍니다.\n   - `Pull Request의 생성 또는 업데이트에 대한 workflow`의 경우 이 단계까지만 수행합니다.\n4. `Pull request Merge에 대한 workflow`의 경우, 빌드한 결과물을 GitHub의 자체 저장소인 `Artifact Storage`에 업로드합니다.\n5. 우리의 `EC2`에 설치된 `Self Hosted Runner`가 4번의 결과물을 다운로드 받습니다.\n6. `Self Hosted Runner`가 배포 스크립트를 실행하게 하여, 필요한 어플리케이션을 실행하고 정적 파일을 적절한 위치에 배치합니다.\n\n2번부터 6번까지, 모두 하나의 workflow 내에서 벌어지는 일입니다.\n\n## 적용 방법\n\n### GitHub Actions workflow\n`workflow`란 하나 이상의 작업을 실행하는, 자동화된 프로세스입니다.  \n레포지토리의 `.github/workflows` 디렉토리에 YAML 파일을 저장해 `workflow` 를 정의할 수 있습니다.\n하나의 레포지토리는 여러 개의 `workflow`를 가질 수 있습니다.\n\n괜찮을지도 서비스에서는\n1. `pull request`에 대한 빌드 및 테스트만 수행하는 상황 vs `pull request merge` 시 배포까지 수행하는 상황\n2. 대상이 `main` 브랜치 vs `dev` 브랜치\n3. 대상이 프론트엔드 / 백엔드\n\n세 가지 상황을 고려하여 여러 개의 `workflow`를 작성했습니다.  \n\n![](.index_image/workflows-dev.jpeg)\n![](.index_image/workflows-prod.jpeg)\n\n### workflow 만들기\n`workflow`는 기본적으로 아래와 같은 요소들을 가져야 합니다.\n1. `workflow`를 유발시킬 하나 이상의 이벤트 : `on`\n2. `workflow`에서 수행할 하나 이상의 작업: `job`\n3. `job` 블록 내에 단계 별 스크립트 또는 익스텐션 실행을 정의: `step`\n\n여기서 주의할 점은, 여러개의 `job`은 기본적으로 병렬적으로 처리된다는 것입니다.  \n순차적으로 실행하고 싶다면, `needs` 블록을 사용해야 합니다.  \n\n\n아래는 현재 적용된 workflow입니다. 이해를 돕기 위해 주석을 추가하였습니다.  \n### 백엔드 CI workflow\n```yaml\nname: Backend CI For Test Validation\n\n# 트리거 설정\non:\n  workflow_dispatch:\n  \n  pull_request:\n    branches: [ main, develop ]\n    paths: backend/** # 해당 디렉토리 내 파일의 변경이 있을 때만 트리거됨\n\n# 테스트 결과 등록을 위한 권한 설정\npermissions: \n  pull-requests: write\n  checks: write\n  contents: write\n  \n# 수행할 작업들\njobs:\n  build-and-comment:\n    # 해당 job을 실행할 환경 설정\n    runs-on: ubuntu-22.04\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up JDK 17\n      uses: actions/setup-java@v3\n      with:\n        java-version: '17'\n        distribution: 'temurin'\n        \n    - name: gradlew 실행 권한 부여\n      run: chmod +x gradlew\n      working-directory: backend\n\n    - name: Gradle build 시작\n      run: ./gradlew clean build\n      working-directory: backend\n\n    - name: 테스트 결과를 PR에 코멘트로 등록합니다\n      uses: EnricoMi/publish-unit-test-result-action@v1\n      if: always()\n      with:\n        files: 'backend/build/test-results/test/TEST-*.xml'\n\n    - name: 테스트 실패 시, 실패한 코드 라인에 Check 코멘트를 등록합니다\n      uses: mikepenz/action-junit-report@v3\n      if: always()\n      with:\n        report_paths: '**/build/test-results/test/TEST-*.xml'\n        token: ${{ github.token }}\n```\n\n### 백엔드 CD workflow\n```yaml\nname: Backend develop CI/CD\n\non:\n  workflow_dispatch:\n  \n  pull_request:\n     # 배포 설정은 main, develop 브랜치 별로 다르게 트리거\n    branches: [ develop ]\n     # 브랜치가 닫힐 때만 트리거\n    types: [closed]\n    paths: backend/**\n\npermissions:\n  contents: read\n  \njobs:\n  build-and-upload:    \n    # Pull Request를 그냥 닫은 게 아니라, merge해서 닫았을 때만 실행\n    if: github.event.pull_request.merged\n    \n    runs-on: ubuntu-22.04\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up JDK 17\n      uses: actions/setup-java@v3\n      with:\n        java-version: '17'\n        distribution: 'temurin'\n        \n    - name: gradlew 실행 권한 부여\n      run: chmod +x gradlew\n      working-directory: backend\n\n    - name: Gradle build 시작\n      run: ./gradlew clean build\n      working-directory: backend\n        \n    - name: jar 파일 artifact에 업로드\n      uses: actions/upload-artifact@v3\n      with:\n        name: BackendApplication\n        path: backend/build/libs/mapbefine.jar\n\n  deploy:\n     # Pull Request를 그냥 닫은 게 아니라, merge해서 닫았을 때만 실행\n     if: github.event.pull_request.merged\n\n     # deploy는 build-and-upload 작업과 달리 self-hosted runner를 사용\n     # main, develop 브랜치마다 각각 운영 서버, 개발 서버의 runner만을 실행하도록 해야 함\n     runs-on: [ self-hosted, dev ]를\n     # build-and-upload 작업이 성공적으로 완료될 경우 실행\n     needs: build-and-upload\n  \n     steps:\n      - name: 구버전 jar 파일 삭제\n        run: rm -rf /home/ubuntu/backend/build/*.jar \n\n      - name: jar파일 artifact에서 다운로드\n        uses: actions/download-artifact@v3 \n        with:\n          name: BackendApplication\n          path: /home/ubuntu/backend/build/\n\n      - name: 배포하기\n        run: /home/ubuntu/backend/deploy.sh\n\n      - name: 슬랙 메시지 보내기\n\n        uses: 8398a7/action-slack@v3\n        with:\n          mention: 'here'\n          if_mention: always\n          status: ${{ job.status }}\n          fields: workflow,job,commit,message,ref,author,took\n        env:\n          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n        if: always()\n```\n\n### 프론트엔드 CI workflow\n프론트엔드 CI는 추후 테스트와 함께 적용 예정입니다.  \n\n### 프론트엔드 CD workflow\n```yaml\nname: Frontend develop CD\n\non:\n  workflow_dispatch:\n\n  pull_request:\n    branches: [ develop ]\n    types: [closed]\n    paths: frontend/**\n\npermissions:\n  contents: read\n\njobs:\n  build-and-upload:\n    if: github.event.pull_request.merged\n\n    runs-on: ubuntu-22.04\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Node.js 18\n        uses: actions/setup-node@v3\n        with:\n          node-version: 18\n          cache: \"npm\"\n\n      - name: Install npm\n        run: npm install --force\n\n      - name: grant excute access\n        run: chmod +x npm\n\n      - name: Build project\n        run: npm run build\n\n      - name: upload to artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: FrontendApplication\n          path: frontend/dist\n\n  deploy:\n      runs-on: [ self-hosted, dev ]\n      needs: build-and-upload\n\n      if: github.event.pull_request.merged\n\n      steps:\n        - name: delete old js file\n          run: rm -rf /home/ubuntu/frontend/dist\n\n        - name: download js file from artifact\n          uses: actions/download-artifact@v3\n          with:\n            name: FrontendApplication\n            path: /home/ubuntu/frontend\n\n        - name: deploy\n          run: /home/ubuntu/frontend/deploy.sh\n\n        - name: send slack message\n\n          uses: 8398a7/action-slack@v3\n          with:\n            mention: 'here'\n            if_mention: always\n            status: ${{ job.status }}\n            fields: workflow,job,commit,message,ref,author,took\n          env:\n            SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n          if: always()\n\n```\n\n## Self-hosted Runner \n앞서 말씀드린 파이프라인 대로 배포를 하기 위해서는, 배포를 할 서버에 `GitHub Actions`의 `Self-hosted Runner`를 설치해야 합니다.  \n\n앞서 설명드린 `workflow`는 GitHub에서 호스팅하는 Runner가 수행할 수도 있지만,  \n원하는 서버에 자체적으로 Runner를 호스팅하여 사용할 수도 있습니다.\n\nworkflow의 `runs-on` 블록에서 어떤 Runner를 통해 작업을 수행할지 정의합니다.\n\n\n\n### EC2에 Self-hosted Runner 띄우기\n\n#### 1. 다운로드  \n레포지토리의 `Settings` - `Actions` - `Runners`에 들어가면 `New self-hosted runner` 버튼이 있습니다.  \n![create-runner.png](.index_image/create-runner.png)\n버튼을 누르면 아래와 같은 설정 페이지로 접속하는데, Runner를 띄울 서버 환경에 맞는 설정을 선택해줍니다.  \n   ![architecture-runner.png](.index_image/architecture-runner.png)\n해당 환경의 터미널에서 runner package를 다운로드합니다. 선택한 설정에 맞게 제공된 커맨드를 복사해 실행하면 됩니다.  \n   ![download-runner.png](.index_image/download-runner.png)   \n\n아래는 Linux, ARM64 환경의 runner를 다운로드받기 위한 스크립트입니다.  \n  ```shell\n  # Create a folder\n  $ mkdir actions-runner && cd actions-runner\n  # Download the latest runner package\n  $ curl -o actions-runner-linux-arm64-2.307.1.tar.gz -L https://github.com/actions/runner/releases/download/v2.307.1/actions-runner-linux-arm64-2.307.1.tar.gz\n  # Optional: Validate the hash\n  $ echo \"01edc84342ef4128a8f19bc2f33709b40f2f1c40e250e2a4c5e0adf620044ab3  actions-runner-linux-arm64-2.307.1.tar.gz\" | shasum -a 256 -c\n  # Extract the installer\n  $ tar xzf ./actions-runner-linux-arm64-2.307.1.tar.gz\n  ```\n   \n#### 2. Runner 생성 및 설정\n마찬가지로 제공된 스크립트에 따라, runner를 생성하고 설정합니다.  \n![configure-runner.png](.index_image/configure-runner.png)\n먼저 아래 커맨드를 실행하면, 아래와 같이 Runner 환경 설정을 위해 몇 가지를 입력해야 합니다.  \n```shell\n$ ./config.sh --url ${repository URL} --token ${runner 생성 페이지에서 제공된 토큰}\n```\n![runner-registration.png](.index_image/runner-registration.png)\n\n위 이미지처럼 name, 추가 label을 지정하고 설치한 runner를 확인하면, 다음과 같이 `dev` 라벨이 추가된 것을 확인할 수 있습니다.\n![runner-label.png](.index_image/runner-label.png)\n> ⚠️ 개인 로컬에서 테스트로 만든 예시 이미지로, 실제 서비스의 운영 환경과는 상이합니다.\n\n더 빠른 설정을 원한다면, 아래와 같이 `./config.sh` 실행 시 원하는 값들을 바로 전달해줘도 됩니다.\n```shell\n$ ./config.sh --url ${repository URL} --token ${runner 생성 페이지에서 제공된 토큰} --name test --labels dev\n```\n\n   > **label을 왜 추가했을까요?**    \n   각 Runner를 구분할 수 있는 label을 지정해서 `runs-on` 블록에서 어떤 Runner에게 일을 시킬지 명시하기 위함입니다.  \n   괜찮을지도 팀은 한 리포지토리에서 운영 서버, 개발 서버에 각각 띄울 두 개의 Runner를 사용하기 때문에\n   이를 구분하기 위한 `dev`, `prod` label을 지정하였습니다.  \n   아래는 `dev`, `self-hosted` 라벨을 가진 runner를 지정하는 예시입니다.\n   ```YAML\n   runs-on: [ self-hosted, dev ]\n   ```\n   > **이미 생성한 Runner에 label을 추가하려면?**  \n   GitHub 공식문서에 따르면, 2023년 2월부터 GUI로 label을 추가하는 기능을 제공하지 않는다고 합니다.    \n   config.sh 파일을 수정해 설정할 수도 없습니다.    \n   대신 GitHub에서 제공하는 \"Self-hosted runners\" REST API를 사용해 추가해주어야 합니다.\n\n#### 3. Runner 실행\n   Runner 설정이 완료되었다면, 아래 명령어로 Runner를 실행합니다.  \n   레포지토리의 `Settings` - `Actions` - `Runners` 페이지에서 Status가 `idle`로 바뀌었다면 정상적으로 실행된 것입니다.\n   ```shell\n   $ ./run.sh\n   ```\n\n참고로 서버 내 저장한 환경변수를 업데이트 했을 때에는, Runner도 재시작하기를 잊지 마세요!  \n왜일까요? 자세한 내용은  \n[EC2 환경 변수 적용 및 Actions Runner에 환경 변수 적용이 안되는 이슈](https://map-befine-official.github.io/trouble-shooting-actions-runner)에서 확인하실 수 있습니다.\n\n\n## 참고 자료\nhttps://docs.github.com/ko/actions/using-workflows/about-workflows  \nhttps://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners  \nhttps://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-labels-with-self-hosted-runners  \n"},{"excerpt":"이 글은 우테코 괜찮을지도팀의 가 작성했습니다. 첫 글은 포스트 작성법에 대해서 다루어보도록 하겠습니다. Repository Local 로 Clone 해오기 본인이 원하는 Directory 로 이동해  위와 같은 명령어를 이용하여 우리 팀의 Repository 를 Local 로 가져옵니다. 글 작성하기 Repository 를 Local 로 가져오셨다면, …","fields":{"slug":"/how-to-write-a-post/"},"frontmatter":{"date":"July 24, 2023","title":"포스트 작성 방법","tags":["블로그"]},"rawMarkdownBody":"\n> 이 글은 우테코 괜찮을지도팀의 `매튜`가 작성했습니다.\n\n첫 글은 포스트 작성법에 대해서 다루어보도록 하겠습니다.\n\n### Repository Local 로 Clone 해오기 \n\n본인이 원하는 Directory 로 이동해 \n\n```shell\ngit clone https://github.com/map-befine-official/map-befine-official.github.io \n``` \n\n위와 같은 명령어를 이용하여 우리 팀의 Repository 를 Local 로 가져옵니다.\n\n## 글 작성하기\n\nRepository 를 Local 로 가져오셨다면, 이제 글을 작성해봅시다!\n\n```shell\ncd map-befine-official.github.io\n```\n\n위 명령어를 통해서 map-befine-official.github.io 에 Directory 에 들어가주시면 Contents Directory 가 보이실 겁니다.\n\n여기서 \n\n```shell\ncd contents/posts\n```\n\n위 명령어를 통해 contents/posts 디렉토리 내부까지 가고\n\n본인이 작성하고자 하는 주제에 걸맞는 이름으로 Directory 를 생성한 후, 만드신 Directory까지 들어가주세요\n\n저 같은 경우는 Directory 명을 how-to-write-a-post 로 지었기 때문에\n\n```shell\ncd how-to-write-a-post\n```\n\n위와 같은 명령어를 통해 이동 해주었습니다.\n\n![](.index_image/command.png)\n\n여기서부터 이제 `index.md` 파일을 만들어 작성하실 글을 Markdown 형식으로 작성 해주시면되고, `.index_image` 라는 이름으로 Directory 만들어 해당 Directory 에 이미지 파일을 넣어주시면 됩니다.\n\n잘 따라오셨다면 최종적으로 이런 구조가 나올겁니다!\n\n![](.index_image/directory_structure.png)\n\n## 글 올리기!\n\n글을 모두 작성하셨다면 이제 올리기만 하면 될 겁니다.\n\n아주 쉽습니다.\n\n그냥 main 브랜치에 push 를 하시면돼요!\n\n`.github/workflows/deploy.yml` 로 인해서 push 만 하셔도 배포 될겁니다.\n\n야물딱지죠?\n\n우리 글도 한번 야무지게 써봅시다!\n\n## 글의 제목 작성하기\n\n글의 서두에 \n\n```text\n---\ntitle: \"제목\"\ndescription: \"설명\"\ndate: \"작성 날짜\"\nupdate: \"수정 날짜\"\ntags:\n  - 태그들\n  - ...\n---\n```\n\n이런 식으로 작성해주셔야지 \n\n![](.index_image/title.png)\n\n위에서 보시는 바와 같이 하실 수 있습니다.\n\n## 이미지 삽입\n\n이미지를 삽입하시고 싶으시다면, \n\n저의 가이드를 모두 잘 따르셨다고 가정했을 때, .index_image 내부에 image 파일을 넣고\n\n```text\n![](.index_image/{이미지 파일 명})\n```\n\n이런 식으로 작성해주시면 이미지도 정상적으로 삽입하실  수 있습니다!\n\n## 주의!\n\n다른 사람들의 정성스런 글을 날리지 않기 위해, 항상 Push 이전에 Pull 해주는 거 잊지 않으셨죠? ㅋㅋㅋ\n\n물론 Warning Message 가 뜨긴 할테지만, 잊지 말아주세용~~~\n\n## 레퍼런스 \n\nhttps://pium-official.github.io/blog-starter/\n\n\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}