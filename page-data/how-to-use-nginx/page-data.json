{"componentChunkName":"component---src-templates-post-jsx","path":"/how-to-use-nginx/","result":{"data":{"site":{"siteMetadata":{"title":"괜찮을지도"}},"markdownRemark":{"id":"fa602b8b-64fa-59b0-b377-089612f91d9f","excerpt":"이 글은 우아한테크코스 괜찮을지도팀의 가 작성했습니다. 지난 글 GitHub Actions로 CI/CD 구축하기에서 현재 저희 프로젝트의 인프라 구조를 간략하게 이미지로 설명드렸습니다. 다시 이미지를 보여드리자면, 서버의 앞단에서 Nginx를 사용하고 있는데요.  ⚠️ 편의상 개발 서버, DB 서버 부분은 생략하고 확대한 이미지입니다. 개발 서버의 Ngin…","html":"<blockquote>\n<p>이 글은 우아한테크코스 괜찮을지도팀의 <code class=\"language-text\">도이</code>가 작성했습니다.</p>\n</blockquote>\n<p>지난 글 <a href=\"https://map-befine-official.github.io/github-actions-ci-cd\">GitHub Actions로 CI/CD 구축하기</a>에서<br>\n현재 저희 프로젝트의 인프라 구조를 간략하게 이미지로 설명드렸습니다.</p>\n<p>다시 이미지를 보여드리자면, 서버의 앞단에서 Nginx를 사용하고 있는데요.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/45ee08747158f5004979e90c9b76cdf4/77dcf/infra_nginx.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 41.1764705882353%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABYklEQVR42oVSy27CMBDMn/cXOFH1E3rsseqtFw4UIQUUDhxQAgkOSdqEOLEdP6a2UyhIlbrS2Ct7PfsYB8YY3OJP0wqQ/Arjdj2ANhWOJEe+fAN7f/ShgVuGYfC4mFIKUkoPn0QJaJfQXV6TGnDGoK0n2wqKbOyRRlDXNRaLBebzOZzvSIqiQBzHSJIEXc+AvoUhR6iihOlrCEsgbdJ4H4Nz/sNvqdWAYL1eoyxLnE4nRFHkq3PVUkohhBiDSYbNMURKdlA5wZm2kIPEfpeCdeyecLVaYTqdYjKZIAxDX2FVVZ6waRp03D44U7x8PCPazrzf2aq0UZglr2i4bVdqCBs38G6cYZZlSNPUJ3JVudbdWU4I+r53qsAcDjBfNYxo8JlnaDnF0/IB+/MWA1N2NBS8a0fCf80pa1vycmjpBVG2kzzNwXv2+xNcy6Nw91/m4pursnY+UoxwhPahx63vYDS+AbnzZ8y1wl3+AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='infra_nginx.png' title='' src='/static/45ee08747158f5004979e90c9b76cdf4/ca1dc/infra_nginx.png' srcset='/static/45ee08747158f5004979e90c9b76cdf4/e7570/infra_nginx.png 170w,\n/static/45ee08747158f5004979e90c9b76cdf4/f46e7/infra_nginx.png 340w,\n/static/45ee08747158f5004979e90c9b76cdf4/ca1dc/infra_nginx.png 680w,\n/static/45ee08747158f5004979e90c9b76cdf4/77dcf/infra_nginx.png 930w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>infra_nginx.png</figcaption>\n  </figure></p>\n<blockquote>\n<p>⚠️ 편의상 개발 서버, DB 서버 부분은 생략하고 확대한 이미지입니다.<br>\n개발 서버의 Nginx도 같은 역할을 수행합니다.<br>\n또, 80 포트 요청에 대해서도 443 포트로 리다이렉트해주고 있으나 이 또한 편의상 그림에는 생략하고 있습니다.  </p>\n</blockquote>\n<p>이번 글에서는 Nginx의 모든 것에 대해 설명하기보다는 Nginx를 왜 썼는지, 어떻게 썼는지에 초점을 맞춰보도록 하겠습니다.  </p>\n<h2>Nginx란?</h2>\n<p>그래도 이게 뭔지 알아야겠죠? 간단하게 설명하면, 경량화된 웹 서버 프로그램입니다.<br>\n정적 파일을 제공하는 HTTP 서버로도, 리버스 프록시 서버로도 사용할 수 있습니다.  </p>\n<p>이제 저희의 Nginx 설정 파일을 보면서 어떻게 활용했는지 설명드리겠습니다.</p>\n<blockquote>\n<p>설정 파일은 과거 방식으로는 /etc/nginx/sites-available 또는 /sites-enabled에서 관리하고,<br>\n최신 방법으로는 /etc/nginx/conf.d 디렉토리에서 관리합니다.<br>\n또, 전역 설정을 관리하는 파일로는 <code class=\"language-text\">/etc/nginx/nginx.conf</code>가 있습니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"properties\"><pre class=\"language-properties\"><code class=\"language-properties\"><span class=\"token key attr-name\">server</span> <span class=\"token value attr-value\">{</span>\n<span class=\"token comment\">        # (1) HTTPS 적용 전, 서버 이름 지정</span>\n<span class=\"token key attr-name\">        server_name</span> <span class=\"token value attr-value\">${도메인};</span>\n\n<span class=\"token comment\">        # (1) HTTPS 적용 : SSL을 사용하여 443포트에서 수신</span>\n<span class=\"token key attr-name\">        listen</span> <span class=\"token value attr-value\">443 ssl; # managed by Certbot</span>\n<span class=\"token key attr-name\">        ssl_certificate</span> <span class=\"token value attr-value\">/etc/letsencrypt/live/${도메인}/fullchain.pem; # managed by Certbot</span>\n<span class=\"token key attr-name\">        ssl_certificate_key</span> <span class=\"token value attr-value\">/etc/letsencrypt/live/${도메인}/privkey.pem; # managed by Certbot</span>\n<span class=\"token key attr-name\">        include</span> <span class=\"token value attr-value\">/etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span>\n<span class=\"token key attr-name\">        ssl_dhparam</span> <span class=\"token value attr-value\">/etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span>\n\n<span class=\"token comment\">        # (3) 웹 서버의 루트 디렉토리 지정</span>\n<span class=\"token key attr-name\">        root</span> <span class=\"token value attr-value\">/var/www/html;</span>\n\n<span class=\"token comment\">        # (3) 웹 서버가 디렉토리를 열 때 사용할 기본 파일 지정 (나열된 순서대로 탐색)</span>\n<span class=\"token key attr-name\">        index</span> <span class=\"token value attr-value\">index.html index.htm index.nginx-debian.html;</span>\n\n<span class=\"token comment\">        # (2, 3) 루트 URL에 대한 동작 정의 : 프론트엔드 정적 파일 서브</span>\n<span class=\"token key attr-name\">        location</span> <span class=\"token value attr-value\">/ {</span>\n<span class=\"token key attr-name\">            root</span> <span class=\"token value attr-value\">/usr/share/nginx/html/dist;</span>\n<span class=\"token key attr-name\">            include</span> <span class=\"token value attr-value\">/etc/nginx/mime.types;</span>\n<span class=\"token key attr-name\">            try_files</span> <span class=\"token value attr-value\">$uri $uri/ /index.html;</span>\n        }\n\n<span class=\"token comment\">        # (2) /api/ URL에 대한 동작 정의 : 백엔드 API 연결</span>\n<span class=\"token key attr-name\">        location</span> <span class=\"token value attr-value\">/api/ {</span>\n<span class=\"token key attr-name\">            rewrite</span> <span class=\"token value attr-value\">^/api/(.*) /$1?$args break;</span>\n<span class=\"token key attr-name\">            proxy_pass</span> <span class=\"token value attr-value\">http://${서버 IP 주소}:8080;</span>\n<span class=\"token key attr-name\">            proxy_set_header</span> <span class=\"token value attr-value\">Host $host;</span>\n<span class=\"token key attr-name\">            proxy_set_header</span> <span class=\"token value attr-value\">X-Real-IP $remote_addr;</span>\n<span class=\"token key attr-name\">            proxy_set_header</span> <span class=\"token value attr-value\">X-Forwarded-For $proxy_add_x_forwarded_for;</span>\n        }\n}\n\n<span class=\"token comment\"># 해당 도메인에 대해 80번 포트 HTTP 요청이 오면 HTTPS로 리다이렉션</span>\n<span class=\"token key attr-name\">server</span> <span class=\"token value attr-value\">{</span>\n<span class=\"token key attr-name\">    if</span> <span class=\"token value attr-value\">($host = ${도메인}) {</span>\n<span class=\"token key attr-name\">        return</span> <span class=\"token value attr-value\">301 https://$host$request_uri;</span>\n<span class=\"token key attr-name\">    }</span> <span class=\"token value attr-value\"># managed by Certbot</span>\n    \n    \n<span class=\"token key attr-name\">    listen</span> <span class=\"token value attr-value\">80 ;</span>\n<span class=\"token key attr-name\">    listen</span> <span class=\"token value attr-value\">[::]:80 ;</span>\n<span class=\"token key attr-name\">    server_name</span> <span class=\"token value attr-value\">${도메인};</span>\n}</code></pre></div>\n<h2>(1) HTTPS 적용하기</h2>\n<p>SSL 인증서만 있으면, 웹서버를 통해 쉽게 HTTPS 프로토콜을 적용할 수 있습니다.<br>\n무료 이용이 가능하고, <code class=\"language-text\">Nginx</code>와 통합하여 사용하기 좋은 <code class=\"language-text\">Certbot</code>을 사용해 이를 적용했습니다.<br>\n전체적인 흐름은 아래와 같습니다.  </p>\n<ol>\n<li>도메인을 구매하고, 레코드 A에 public IP 주소를 등록한다.</li>\n<li><code class=\"language-text\">Cerbot</code>을 설치한다.</li>\n<li>설정 파일의 server_name을 구매한 도메인으로 변경한다.</li>\n<li><code class=\"language-text\">Certbot</code>을 이용해 구매한 도메인을 이용해 SSL 인증서를 발급받는다.</li>\n<li>인증서를 발급받으면, <code class=\"language-text\">Certbot</code>이 자동으로 설정 파일에서 server_name이 일치하는 블록을 찾아 SSL 관련 내용들을 추가해준다.</li>\n</ol>\n<p><code class=\"language-text\"># managed by Certbot</code>이라는 주석이 붙어있는 내용들이 <code class=\"language-text\">Certbot</code>이 추가해준 내용입니다.</p>\n<blockquote>\n<p><code class=\"language-text\">Certbot</code>은 SSL 인증 발급 도구로, 무료 SSL 인증서 발급 기관인 <code class=\"language-text\">Let's Encrypt</code>와 통합되어 있습니다.<br>\n이를 통해 쉽게 SSL 인증서를 발급받을 수 있습니다.<br>\n또, <code class=\"language-text\">Nginx</code> 설정 파일을 자동 업데이트하는 방식으로 SSL 인증서를 적용할 수 있어 편리합니다.\n단, 유효 기간이 90일이기 때문에 자동 갱신 설정이 별도로 필요합니다.  </p>\n</blockquote>\n<p>하단에 첨부한 참고 자료와 같이, 잘 정리된 자료가 기존에 많기 때문에 자세한 내용은 생략하겠습니다.</p>\n<h2>(2) 프론트엔드, 백엔드 요청 구분하기</h2>\n<p>저희 프로젝트의 인프라 구조에서는 프론트엔드와 백엔드가 같은 서버를 공유하므로<br>\n클라이언트가 이용하는 화면에 대한 요청과, 백엔드 API에 대한 요청을 구분할 필요가 있었습니다.  </p>\n<p><code class=\"language-text\">location</code> 블록을 사용해 특정 URL에 대한 동작을 설정하는 방식으로 이를 구분할 수 있었습니다.  </p>\n<p>해당하는 부분을 가져와 설명드리겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"properties\"><pre class=\"language-properties\"><code class=\"language-properties\"><span class=\"token comment\"># 루트 URL에 대해 프론트엔드 정적 파일 서브</span>\n<span class=\"token key attr-name\">location</span> <span class=\"token value attr-value\">/ {</span>\n<span class=\"token key attr-name\">    root</span> <span class=\"token value attr-value\">/usr/share/nginx/html/dist;</span>\n<span class=\"token key attr-name\">    include</span> <span class=\"token value attr-value\">/etc/nginx/mime.types;</span>\n<span class=\"token key attr-name\">    try_files</span> <span class=\"token value attr-value\">$uri $uri/ /index.html;</span>\n}\n\n<span class=\"token comment\"># /api/ URL에 대해 백엔드 API 연결</span>\n<span class=\"token key attr-name\">location</span> <span class=\"token value attr-value\">/api/ {</span>\n<span class=\"token key attr-name\">    rewrite</span> <span class=\"token value attr-value\">^/api/(.*) /$1?$args break; # URL에서 /api 제거</span>\n<span class=\"token key attr-name\">    proxy_pass</span> <span class=\"token value attr-value\">http://${서버 IP 주소}:8080;</span>\n<span class=\"token key attr-name\">    proxy_set_header</span> <span class=\"token value attr-value\">Host $host;</span>\n<span class=\"token key attr-name\">    proxy_set_header</span> <span class=\"token value attr-value\">X-Real-IP $remote_addr;</span>\n<span class=\"token key attr-name\">    proxy_set_header</span> <span class=\"token value attr-value\">X-Forwarded-For $proxy_add_x_forwarded_for;</span>\n}</code></pre></div>\n<p><code class=\"language-text\">https://mapbefine.com/api/</code> 로 시작하는 URL에 대해서는 백엔드 API와 연결합니다.  </p>\n<p>이 설정을 맞추어, 백엔드 코드에서 <code class=\"language-text\">/api</code>가 추가된 요청 URL을 매핑할 수도 있습니다.<br>\n하지만 이는 자원을 명시하기 위한 내용보다는 요청을 구분하기 위함이므로,<br>\n리버시 프록시를 거치고 나면 실제로는 <code class=\"language-text\">/api</code>를 제외한 요청 URL로 연결되도록 하였습니다.<br>\n<code class=\"language-text\"># URL에서 /api 제거</code> 주석이 있는 부분이 해당하는 내용입니다.  </p>\n<blockquote>\n<p><code class=\"language-text\">proxy_set_header</code>는 Nginx가 프록시 요청을 전달하기 전에, HTTP 요청 헤더를 설정하는 지시문입니다.<br>\n원래 요청의 호스트 이름을 백엔드 서버에 전달합니다.<br>\n필수 설정은 아니지만 IP 기반의 접근 제어, 로깅, 다중 호스트 설정 등에 유용할 수 있다고 합니다.  </p>\n</blockquote>\n<h2>(3) 정적 파일 서브하기</h2>\n<p>저희는 프론트엔드의 React를 서버에서 실행시키는 대신, 빌드 결과물을 정적 파일로 서브하는 방식을 택하였습니다.<br>\n이유는 다음과 같습니다.  </p>\n<ol>\n<li>어플리케이션을 서버 내에 실행하여 동적으로 파일을 생성해야 하는 상황이 아닙니다.</li>\n<li>정적 파일로 서브하여 서버 메모리를 절약할 수 있습니다.</li>\n</ol>\n<p>어플리케이션을 실행시킨 상태라면, 해당하는 URL에 대해 3000번 포트로 포워딩해주면 됩니다.</p>\n<p>반면 정적 파일로 서브한다면 어떻게 해야 할요?<br>\n해당하는 부분을 가져와 설명드리겠습니다.</p>\n<p>아래 내용은 설정 파일의 기본 값과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"properties\"><pre class=\"language-properties\"><code class=\"language-properties\"><span class=\"token comment\"># (3) 웹 서버의 루트 디렉토리 지정</span>\n<span class=\"token key attr-name\">root</span> <span class=\"token value attr-value\">/var/www/html;</span>\n\n<span class=\"token comment\"># (3) 웹 서버가 디렉토리를 열 때 사용할 기본 파일 지정 (나열된 순서대로 탐색)</span>\n<span class=\"token key attr-name\">index</span> <span class=\"token value attr-value\">index.html index.htm index.nginx-debian.html;</span></code></pre></div>\n<p><code class=\"language-text\">https://mapbefine.com</code> 요청이 들어오면, Nginx는 루트 디렉토리의 <code class=\"language-text\">index.html</code>을 우선적으로 찾아 반환합니다.<br>\n따라서 해당 웹 서버의 루트 디렉토리에 우리의 빌드 결과물인 <code class=\"language-text\">index.html</code>와 모듈 파일들을 위치시키면 됩니다.<br>\n반대로, 정적 파일을 저장하고 있는 위치를 root 값으로 설정해주어도 좋습니다.</p>\n<h2>결론</h2>\n<p>괜찮을지도 서버의 Nginx는<br>\n클라이언트와 WAS(Spring Boot) 사이에 Nginx를 두어 리버스 프록시 서버로 사용하며,<br>\n동시에 HTTPS 적용을 해결하고 HTTP 서버와 같이 정적 파일 서브도 수행하고 있습니다.</p>\n<p>다만 현재 규모에서 간단한 방법을 택한 것으로,<br>\n서비스의 규모가 커짐에 따라 정적 파일을 별도 서버에 관리하는 것이 유리하거나 동적인 파일 생성이 필요한 경우 활용 방식은 얼마든지 달라질 수 있을 것입니다.</p>\n<h2>참고자료</h2>\n<p><a href=\"https://nginx.org/en/docs/\">Nginx 공식 문서</a><br>\n<a href=\"https://www.baeldung.com/linux/sites-available-sites-enabled-conf-d\">baledung - sites-available &#x26; sites-enabled, conf.d 설정 파일 방식 차이</a><br>\n<a href=\"https://hudi.blog/https-with-nginx-and-lets-encrypt/\">Nginx와 Let's Encrypt로 HTTPS 웹 서비스 배포하기 (feat. Certbot)</a><br>\n<a href=\"https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-22-04\">how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-22-04 (Step2 부분 참고)</a></p>","frontmatter":{"title":"괜찮을지도의 Nginx 활용법","date":"August 01, 2023","update":"August 01, 2023","tags":["인프라"],"series":null},"fields":{"slug":"/how-to-use-nginx/","readingTime":{"minutes":10.375}}},"seriesList":{"edges":[{"node":{"id":"9e6463d2-18de-5fdf-b4e6-8707709710e1","fields":{"slug":"/how-to-write-a-post/"},"frontmatter":{"title":"포스트 작성 방법"}}},{"node":{"id":"b802f2fe-d332-504c-be84-fd7aa170c622","fields":{"slug":"/github-actions-ci-cd/"},"frontmatter":{"title":"GitHub Actions로 CI/CD 구축하기"}}},{"node":{"id":"45b7dc00-ae71-58e4-9dc2-7aff92f0ca0d","fields":{"slug":"/trouble-shooting-actions-runner/"},"frontmatter":{"title":"EC2 환경 변수 적용 및 Actions Runner에 환경 변수 적용이 안되는 이슈"}}},{"node":{"id":"cb221d09-1977-59c9-9bc3-cd607a15d292","fields":{"slug":"/how-to-isolating-test/"},"frontmatter":{"title":"인수테스트에서 테스트 격리하기!"}}},{"node":{"id":"fa602b8b-64fa-59b0-b377-089612f91d9f","fields":{"slug":"/how-to-use-nginx/"},"frontmatter":{"title":"괜찮을지도의 Nginx 활용법"}}},{"node":{"id":"89dc33ed-1ad0-5d79-8148-b1a16f417a71","fields":{"slug":"/trouble-shooting-modifying-annotation/"},"frontmatter":{"title":"@Modifying 어노테이션의 옵션이 정상 동작하지 않는 문제"}}},{"node":{"id":"db91695e-5bf6-554c-bafd-e161d686fadf","fields":{"slug":"/trouble-shooting-fetch-type/"},"frontmatter":{"title":"FetchType.EAGER, FetchType.LAZY 에 대해서 알아보자!"}}},{"node":{"id":"2b3c31ce-d59e-50a0-92b2-7dc228aacf29","fields":{"slug":"/jpa-multibag-fetch-exception/"},"frontmatter":{"title":"Fetch join 사용 시 MultipleBagFetchException의 발생 이유와 해결 방법"}}},{"node":{"id":"253d110b-e241-549e-923a-f26782aab2dc","fields":{"slug":"/how-to-hikariCP/"},"frontmatter":{"title":"HikariCP 적용기"}}},{"node":{"id":"50f61fc3-c2e2-5599-b7e8-64879a64275d","fields":{"slug":"/trouble-shooting-jpa-delete-and-persistence/"},"frontmatter":{"title":"JPA 엔티티를 삭제할 때 영속성과 연관 관계가 중요한 이유"}}},{"node":{"id":"4a76962f-5c50-5617-84e6-286b77281734","fields":{"slug":"/how-to-optimize-website/"},"frontmatter":{"title":"괜찮을지도 사이트 최적화 진행"}}},{"node":{"id":"17b8f808-e28d-5eb8-a407-fba6191a1ea7","fields":{"slug":"/how-to-store-image-s3/"},"frontmatter":{"title":"백엔드와 협력해 S3에 이미지 저장하기"}}}]},"previous":{"fields":{"slug":"/how-to-isolating-test/"},"frontmatter":{"title":"인수테스트에서 테스트 격리하기!"}},"next":{"fields":{"slug":"/trouble-shooting-modifying-annotation/"},"frontmatter":{"title":"@Modifying 어노테이션의 옵션이 정상 동작하지 않는 문제"}}},"pageContext":{"id":"fa602b8b-64fa-59b0-b377-089612f91d9f","series":null,"previousPostId":"cb221d09-1977-59c9-9bc3-cd607a15d292","nextPostId":"89dc33ed-1ad0-5d79-8148-b1a16f417a71"}},"staticQueryHashes":[],"slicesMap":{}}