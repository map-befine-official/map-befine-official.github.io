{"componentChunkName":"component---src-templates-post-jsx","path":"/jpa-multibag-fetch-exception/","result":{"data":{"site":{"siteMetadata":{"title":"괜찮을지도"}},"markdownRemark":{"id":"2b3c31ce-d59e-50a0-92b2-7dc228aacf29","excerpt":"이 글은 우테코 괜찮을지도팀의 가 작성했습니다. N+1과 Fetch join 백엔드에서는 조회 API로 여러 연관 관계로 인해 발생하는 N+1 문제를 해결해야 했는데요. 예를 들면 장소(이하 핀) 다건 조회의 경우, 각 핀이 속한 지도(topic), 위치, 생성자, 핀 이미지들을 모두 별도로 조회하는 심각한 문제가 있었습니다. 지도(topic) 조회 시에…","html":"<blockquote>\n<p>이 글은 우테코 괜찮을지도팀의 <code class=\"language-text\">도이</code>가 작성했습니다.</p>\n</blockquote>\n<h2>N+1과 Fetch join</h2>\n<p>백엔드에서는 조회 API로 여러 연관 관계로 인해 발생하는 N+1 문제를 해결해야 했는데요.<br>\n예를 들면 장소(이하 핀) 다건 조회의 경우, 각 핀이 속한 지도(topic), 위치, 생성자, 핀 이미지들을 모두 별도로 조회하는 심각한 문제가 있었습니다.<br>\n지도(topic) 조회 시에도 생성자, 권한 정보, 즐겨찾기 목록을 매번 불러왔고요.   </p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/d27c9c172301ef1549f5e11026dc75e9/9ae5c/img.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 122.94117647058822%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEmElEQVR42k1VaW/bRhDl//8VAQoE/VAURe0ARpMYjWzrjG5RFEWK96Wbknjo9OvMMlQtYERid+fN9fZRCjcJHt9GeHjtoTL2hf1QAjRUH5frFS9DB5+fe3jsmHjo2GhqAa60Xh3Z+P1rAw/VIb4NPbwpLi7nC6RlfEB9oOL15wBv3TG6qgV7eYC72uF0PsOPIrTaHYwVFabtYLXe4na7wLBdVNsD6G6IbX7Fap/hdDpByvIMk4kMQ9dgznS4toX395vI4nq5YB+v4bou4niLI5290FqSpvCDALZlwKHznmNjMY/EnpTnKQxDg+8H2Gw2mC8WBPiOM23GcQzPsjCdTjEajbDdbnE4HBDvdvDCkBKZQNM0dLtdzOdzyvwGKckyzEwqkyJZ5KzrOhzHwX6/F6DhcglVVcmZjJ4clNdNOtMfDDEcyXA9H0EQ4ng8QorJcSDLGPR76FGkfr+Peq0GWR6JiKvNGp7rwCWANEnEGvfK9OYYaTaGUxN91cBYt4uSo+UazdEU9f5YWIOs1hujM1KFo6LqqNSaeK5U8W+1gYluCEduC4Pzs3znvkvlIu4bxaZYJzsSFaLVBhw4mK+QZLlwZNCPdhZPAowPR7iLLaxohflmX0z3ShncrrCjGI2xiYE1R1v3Mfa3kJ0lDgTKwRioOP+/SYoV4rcvL/jrpYe66lFjT4Iu7CAT0N8/WniqD/EmW+jZK/StBeJDegfkCvLTGSn55czD/XoOXVXgEKcWUYgdUSKjyXPJ+90Gtmlgs1oipuEkRBn+8TTLSmpDE5++vOKp76KlB5Asx8PP/giVegt9eYIzRWPAhCbqhz66vR6mmk5c1ARlrhSI+ZkSuZlaYeAJ2kWLJTbbGNIuSWH5c1hehMUmLm4CgeV5jnW8Q0SE9X1fcHRJnOTMGYyzZJLrxM1Op4NavQ7TNCHxZC90Z89UP0+aAcuSfbo1PcqQb4lHoGc6x+v3kumsHS4hGy4GmoWZQyXzBh9gkDIq91GUTMLAUfmKLQicf3ye97mCNEtxYnACLmknleNmQCYyZ8HAvLmlXvGV9Egc2DgIT5erKcnMPhmBl3yUrkTG27UoIyd+5QScUY84okEgrU6X+tMsrNFElZ48jNsv2jAgZ3vnYZzk+LMyxOd/avg6cPFN9vHYNvCTKBAu1lDMABPLx8T0IM8cKIZH8pWJTAuZo1tyLjIWgMdTju5wiFZ3ANOPoDs+NocccUKDoQOcKf+K8o73Pp6I0IttAod8TGLIcpciJ3JLrMqsZb7nCUWxiMhlb3hA3Nv0Fy+ZLgzG2W33Kf54buPTYwVPbQ3fZapovSPFJscxCyhl2W63hVgmH2TqfvmZWh8sownbjkVqTp+F5YISMUVAie9fQBmyzDNxmR7swJlws/mdAflwSS1e59uiUyKKopB2yoL8vC4AWX1Zyj1SXv5W8MaeymUQfi95WqoLZ89VKMoEPVLtMam5G7AO7AtA3ZgJtWZQ7mVA0dar1V0XSyt0kAGvYtIqTX9Mk2frT2b0rSFA/mvLGpoDBU1S6+5YQ2swgawZ4gaUJZfP8r3MtFTskjb/AeCRUAJcR56vAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img.png' title='' src='/static/d27c9c172301ef1549f5e11026dc75e9/ca1dc/img.png' srcset='/static/d27c9c172301ef1549f5e11026dc75e9/e7570/img.png 170w,\n/static/d27c9c172301ef1549f5e11026dc75e9/f46e7/img.png 340w,\n/static/d27c9c172301ef1549f5e11026dc75e9/ca1dc/img.png 680w,\n/static/d27c9c172301ef1549f5e11026dc75e9/9ae5c/img.png 751w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>img.png</figcaption>\n  </figure></p>\n<p>따라서 함께 가져올 연관 관계들에 대해 <code class=\"language-text\">Fetch join</code>을 적용하는 방식으로 문제에 접근했습니다.  </p>\n<blockquote>\n<p><code class=\"language-text\">Fetch join</code>은 JPQL에서 성능 최적화를 위해 제공하는 기능입니다.  </p>\n</blockquote>\n<h3>@EntityGraph</h3>\n<p><code class=\"language-text\">Fetch join</code>을 위한 방법으로는, <code class=\"language-text\">@EntityGraph</code>를 선택했습니다.<br>\nJPQL에 직접 하드코딩으로 쿼리를 작성하는 것보다, 가독성 및 유지보수성에 더 좋다고 판단했기 때문입니다.</p>\n<p><code class=\"language-text\">@EntityGraph</code>는, 객체를 로딩할 때 런타임 성능을 개선하기 위해 JPA 2.1에서 도입된 기능입니다.<br>\nJPA 2.0 이전까지는 <code class=\"language-text\">FetchType</code>으로만 로딩 전략을 지정할 수 있었지만<br>\n이를 통해 객체의 연관 관계 중 그래프로 연결할 것들을 템플릿으로 정의하고, 런타임에 선택할 수 있습니다.<br>\n원하는 필드들만 쉽게 Fetch join 시킬 수 있는 것이죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// PinRepository.class</span>\n<span class=\"token comment\">// 해당 쿼리로 데이터를 읽을 때, Topic의 필드로 존재하는 \"location\", \"topic\", \"creator\", \"pinImages\"를 Fetch join으로 불러옵니다.</span>\n<span class=\"token annotation punctuation\">@EntityGraph</span><span class=\"token punctuation\">(</span>attributePaths <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"location\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"topic\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"creator\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"pinImages\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Pin</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAllByCreatorId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>문제 상황</h2>\n<p><code class=\"language-text\">@EntityGraph</code>는 동적으로 생성되므로<br>\n해당 어노테이션에 작성한 설정이 잘못 되었어도, 컴파일 타임이 아니라 해당 쿼리를 사용하는 런타임 시점에 예외가 발생합니다.  </p>\n<p>여러 필드들을 <code class=\"language-text\">attributePaths</code>에 넣어본 뒤, 로컬 환경에서 API를 호출하며 쿼리 개수 및 지연 시간을 확인하던 중<br>\n아래와 같은 오류가 발생했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags: \n[com.mapbefine.mapbefine.topic.domain.Topic.bookmarks, com.mapbefine.mapbefine.topic.domain.Topic.permissions]</code></pre></div>\n<p>호출된 쿼리는 아래와 같았습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// TopicRepository.class</span>\n<span class=\"token annotation punctuation\">@EntityGraph</span><span class=\"token punctuation\">(</span>attributePaths <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"creator\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"permissions\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bookmarks\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Topic</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>MultipleBagFetchException의 발생 이유</h2>\n<p>간단하게 이야기하면 <strong><code class=\"language-text\">OneToMany</code> 관계를 1개보다 더 많이 Fetch join</strong> 하려고 했기 때문에 발생한 문제입니다.<br>\n\"permissons\"와 \"bookmarks\"를 동시에 Fetch join할 수 없습니다.</p>\n<h3>Fetch join과 카테시안 곱</h3>\n<p>Fetch join은 <code class=\"language-text\">*ToOne</code> 관계에는 개수 제한이 없지만, <code class=\"language-text\">*ToMany</code> 관계를 1개만 사용할 수 있습니다.<br>\nfech join을 여러 개의 컬렉션에 적용한다면, 카테시안 곱에 의해 중복 데이터가 발생하기 때문입니다.<br>\nHibernate은 이에 대해 <code class=\"language-text\">MultipleBagFetchException</code> 예외를 던져 해당 상황 자체를 막습니다.  </p>\n<p>물론 하나의 <code class=\"language-text\">OneToMany</code>를 Fetch join 해도 join 대상인 엔티티 기준으로는 중복이 발생합니다.<br>\n하지만 이에 대해서는 JPQL에서 지원하는 distinct를 사용해 엔티티의 중복을 제거할 수 있습니다.  </p>\n<blockquote>\n<p><code class=\"language-text\">Bag</code>은 Hibernate 용어로, Set과 같이 순서가 없고 List와 같이 중복을 허용하는 자료구조입니다.<br>\n그러나 Java Collection API에는 위와 같은 개념의 자료구조가 없기 때문에, List를 Bag으로 사용합니다.<br>\nList 로 초기화한 경우, PersistentBag 이라는 인스턴스로 매핑됩니다.<br>\n반면 Set 으로 초기화한 경우, PersistentSet 이라는 인스턴스로 매핑됩니다.</p>\n</blockquote>\n<h2>해결 방법</h2>\n<p>앞서 발생한 상황의 경우,<br>\n즐겨찾기 개수에 대한 역정규화로 인해 \"bookmarks\"의 Fetch join이 필요가 없어지면서 문제 자체가 사라졌습니다.<br>\n하지만 해당 예외에 대한 해결 방법과, 이러한 문제를 회피하면서 성능을 개선할 수 있는 방법을 알아두면 도움이 될 것입니다.   </p>\n<p>먼저 해당 예외에 대한 단순 해결 방법으로는 아래와 같은 것이 있습니다.   </p>\n<h3>1. 자료형을 Set으로 변경</h3>\n<p>Set은 중복을 허용하지 않기 때문에 이 경우 여러 개의 <code class=\"language-text\">*ToMany</code>를 허용해줍니다.<br>\n하지만 순서를 보장할 수 없다는 단점이 있습니다.  </p>\n<blockquote>\n<p>이로 인해 화면 상 보이는 지도 목록 순서가 매번 바뀌는 문제를 겪기도 했습니다.<br>\nHibernate에서는 DB에서 읽어온 데이터를 저장할 때,<br>\nList와 달리 Set에 대해서는 순서 보장을 지원하지 않기 때문에 LinkedHashSet으로도 소용이 없었습니다.</p>\n</blockquote>\n<h3>2. 자식 엔티티 중 하나에만 Fetch join을 걸고, 나머지는 Lazy loading</h3>\n<p>해당 예외를 피하는 방법이긴 하지만, 기존에 목표로 삼던 성능 개선과는 거리가 멀어질 수 있습니다.   </p>\n<p>그 외에도 Fetch join 쿼리를 나누어 실행하거나, 쿼리를 여러 개로 나누었다 조립하는 방법도 있습니다.<br>\n<strong>하지만 결국 원하는 건 쿼리의 수를 줄이고 성능을 개선하는 것인데, 간단하고 좋은 방법 없을까요? 🤔</strong></p>\n<h3>3. default<em>batch</em>fetch_size 설정</h3>\n<p>불가피하게 여러 개의 <code class=\"language-text\">*ToMany</code>를 Fetch join 해야 할 경우,<br>\n2번 방법을 적용하되 이 방법을 사용하면 Lazy loading으로 인해 발생하는 쿼리도 획기적으로 줄일 수 있습니다.</p>\n<p>Hibernate의 <code class=\"language-text\">default_batch_fetch_size</code> 설정을 바꾸면 여러 개의 <code class=\"language-text\">*ToMany</code>를 사용하고도 N+1 문제를 회피할 수 있기 때문입니다.<br>\n자식 엔티티를 조회할 때는, 외래키를 사용해 아래와 같은 쿼리가 나갑니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> permission <span class=\"token keyword\">where</span> topic_id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> permission <span class=\"token keyword\">where</span> topic_id <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ... 조회할 모든 토픽에 대해 쿼리 발생</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> bookmark <span class=\"token keyword\">where</span> topic_id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> bookmark <span class=\"token keyword\">where</span> topic_id <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ... 조회할 토픽에 대해 쿼리 발생</span></code></pre></div>\n<p>하지만 해당 옵션은 지정된 수(size) 만큼, in 절에 부모 key를 사용하는 방식으로 자식 엔티티들을 조회하도록 바꿔줍니다.<br>\n조회하는 topic 개수 만큼 나가던 쿼리를 각 1번씩으로 줄일 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> permission <span class=\"token keyword\">where</span> topic_id <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> bookmark <span class=\"token keyword\">where</span> topic_id <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>참고 자료</h2>\n<ul>\n<li><a href=\"https://www.baeldung.com/jpa-entity-graph\">https://www.baeldung.com/jpa-entity-graph</a></li>\n<li><a href=\"https://www.baeldung.com/java-hibernate-multiplebagfetchexception\">https://www.baeldung.com/java-hibernate-multiplebagfetchexception</a></li>\n<li><a href=\"https://docs.spring.io/spring-data/data-jpa/docs/current/api/org/springframework/data/jpa/repository/EntityGraph.html\">https://docs.spring.io/spring-data/data-jpa/docs/current/api/org/springframework/data/jpa/repository/EntityGraph.html</a></li>\n<li><a href=\"https://jojoldu.tistory.com/457?fbclid=IwAR132BRMYHrL4D5Pu25YUglIcEN1FGTE2tacFcsVOPAT0MAzwoMX6Flzbe0\">https://jojoldu.tistory.com/457?fbclid=IwAR132BRMYHrL4D5Pu25YUglIcEN1FGTE2tacFcsVOPAT0MAzwoMX6Flzbe0</a></li>\n<li><a href=\"https://devlog-wjdrbs96.tistory.com/421\">https://devlog-wjdrbs96.tistory.com/421</a></li>\n</ul>","frontmatter":{"title":"Fetch join 사용 시 MultipleBagFetchException의 발생 이유와 해결 방법","date":"October 04, 2023","update":"October 04, 2023","tags":["Spring Data JPA","Hibernate","JPQL","트러블슈팅"],"series":null},"fields":{"slug":"/jpa-multibag-fetch-exception/","readingTime":{"minutes":8.29}}},"seriesList":{"edges":[{"node":{"id":"9e6463d2-18de-5fdf-b4e6-8707709710e1","fields":{"slug":"/how-to-write-a-post/"},"frontmatter":{"title":"포스트 작성 방법"}}},{"node":{"id":"b802f2fe-d332-504c-be84-fd7aa170c622","fields":{"slug":"/github-actions-ci-cd/"},"frontmatter":{"title":"GitHub Actions로 CI/CD 구축하기"}}},{"node":{"id":"45b7dc00-ae71-58e4-9dc2-7aff92f0ca0d","fields":{"slug":"/trouble-shooting-actions-runner/"},"frontmatter":{"title":"EC2 환경 변수 적용 및 Actions Runner에 환경 변수 적용이 안되는 이슈"}}},{"node":{"id":"cb221d09-1977-59c9-9bc3-cd607a15d292","fields":{"slug":"/how-to-isolating-test/"},"frontmatter":{"title":"인수테스트에서 테스트 격리하기!"}}},{"node":{"id":"fa602b8b-64fa-59b0-b377-089612f91d9f","fields":{"slug":"/how-to-use-nginx/"},"frontmatter":{"title":"괜찮을지도의 Nginx 활용법"}}},{"node":{"id":"89dc33ed-1ad0-5d79-8148-b1a16f417a71","fields":{"slug":"/trouble-shooting-modifying-annotation/"},"frontmatter":{"title":"@Modifying 어노테이션의 옵션이 정상 동작하지 않는 문제"}}},{"node":{"id":"db91695e-5bf6-554c-bafd-e161d686fadf","fields":{"slug":"/trouble-shooting-fetch-type/"},"frontmatter":{"title":"FetchType.EAGER, FetchType.LAZY 에 대해서 알아보자!"}}},{"node":{"id":"2b3c31ce-d59e-50a0-92b2-7dc228aacf29","fields":{"slug":"/jpa-multibag-fetch-exception/"},"frontmatter":{"title":"Fetch join 사용 시 MultipleBagFetchException의 발생 이유와 해결 방법"}}},{"node":{"id":"253d110b-e241-549e-923a-f26782aab2dc","fields":{"slug":"/how-to-hikariCP/"},"frontmatter":{"title":"HikariCP 적용기"}}},{"node":{"id":"50f61fc3-c2e2-5599-b7e8-64879a64275d","fields":{"slug":"/trouble-shooting-jpa-delete-and-persistence/"},"frontmatter":{"title":"JPA 엔티티를 삭제할 때 영속성과 연관 관계가 중요한 이유"}}},{"node":{"id":"4a76962f-5c50-5617-84e6-286b77281734","fields":{"slug":"/how-to-optimize-website/"},"frontmatter":{"title":""}}},{"node":{"id":"17b8f808-e28d-5eb8-a407-fba6191a1ea7","fields":{"slug":"/how-to-store-image-s3/"},"frontmatter":{"title":"백엔드와 협력해 S3에 이미지 저장하기"}}}]},"previous":{"fields":{"slug":"/trouble-shooting-fetch-type/"},"frontmatter":{"title":"FetchType.EAGER, FetchType.LAZY 에 대해서 알아보자!"}},"next":{"fields":{"slug":"/how-to-hikariCP/"},"frontmatter":{"title":"HikariCP 적용기"}}},"pageContext":{"id":"2b3c31ce-d59e-50a0-92b2-7dc228aacf29","series":null,"previousPostId":"db91695e-5bf6-554c-bafd-e161d686fadf","nextPostId":"253d110b-e241-549e-923a-f26782aab2dc"}},"staticQueryHashes":[],"slicesMap":{}}